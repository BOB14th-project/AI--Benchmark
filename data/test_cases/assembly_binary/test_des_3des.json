{
  "input_data": "; DES and 3DES implementation in x86-64 assembly\n; Both algorithms vulnerable to quantum attacks via Grover's algorithm\n\n.section .data\n; DES S-boxes (simplified)\ndes_sbox1: .byte 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7\n           .byte 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8\n           ; ... (remaining S-box entries)\n\ndes_sbox2: .byte 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10\n           .byte 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5\n           ; ... (remaining S-box entries)\n\n; DES permutation tables\ninitial_perm: .byte 58, 50, 42, 34, 26, 18, 10, 2\n              .byte 60, 52, 44, 36, 28, 20, 12, 4\n              ; ... (remaining permutation)\n\nfinal_perm:   .byte 40, 8, 48, 16, 56, 24, 64, 32\n              .byte 39, 7, 47, 15, 55, 23, 63, 31\n              ; ... (remaining permutation)\n\n.section .text\n.global des_encrypt\n.global des3_encrypt\n.global des_key_schedule\n\n; DES key schedule generation\ndes_key_schedule:\n    push rbp\n    mov rbp, rsp\n    push rbx\n    push r12\n    push r13\n    \n    mov r12, rdi        ; 64-bit DES key\n    mov r13, rsi        ; output: 16 round keys\n    \n    ; Extract 56-bit key (remove parity bits)\n    mov rax, r12\n    call remove_parity_bits\n    \n    ; Split into C0 and D0 (28 bits each)\n    mov rbx, rax\n    shr rbx, 28         ; D0\n    and rax, 0x0FFFFFFF ; C0\n    \n    ; Generate 16 round keys\n    xor r14, r14        ; round counter\n    \nkey_gen_loop:\n    cmp r14, 16\n    jge key_gen_done\n    \n    ; Determine rotation amount (1 or 2 bits)\n    mov rcx, 1\n    cmp r14, 0\n    je apply_rotation\n    cmp r14, 1\n    je apply_rotation\n    cmp r14, 8\n    je apply_rotation\n    cmp r14, 15\n    je apply_rotation\n    mov rcx, 2\n    \napply_rotation:\n    ; Rotate C and D\n    rol eax, cl\n    and eax, 0x0FFFFFFF\n    rol ebx, cl\n    and ebx, 0x0FFFFFFF\n    \n    ; Combine and apply PC-2 permutation\n    shl rbx, 28\n    or rbx, rax\n    \n    ; Apply PC-2 to get 48-bit round key\n    mov rdi, rbx\n    call pc2_permutation\n    mov [r13 + r14*8], rax\n    \n    inc r14\n    jmp key_gen_loop\n    \nkey_gen_done:\n    pop r13\n    pop r12\n    pop rbx\n    pop rbp\n    ret\n\n; DES encryption function\ndes_encrypt:\n    push rbp\n    mov rbp, rsp\n    push rbx\n    push r12\n    push r13\n    push r14\n    \n    mov r12, rdi        ; 64-bit plaintext\n    mov r13, rsi        ; round keys\n    mov r14, rdx        ; output buffer\n    \n    ; Apply initial permutation\n    mov rdi, r12\n    call initial_permutation\n    \n    ; Split into L0 and R0 (32 bits each)\n    mov rbx, rax\n    shr rbx, 32         ; R0\n    and rax, 0xFFFFFFFF ; L0\n    \n    ; 16 rounds of DES\n    xor r15, r15        ; round counter\n    \ndes_round_loop:\n    cmp r15, 16\n    jge des_rounds_done\n    \n    ; F function: f(R, K)\n    mov rdi, rbx        ; R\n    mov rsi, [r13 + r15*8]  ; round key\n    call des_f_function\n    \n    ; L_{i+1} = R_i\n    ; R_{i+1} = L_i XOR f(R_i, K_i)\n    xor rax, rax        ; L_i XOR f(R_i, K_i)\n    mov rcx, rbx        ; temp = R_i\n    mov rbx, rax        ; R_{i+1}\n    mov rax, rcx        ; L_{i+1}\n    \n    inc r15\n    jmp des_round_loop\n    \ndes_rounds_done:\n    ; Combine final L and R (note: R||L, not L||R)\n    shl rbx, 32\n    or rbx, rax\n    \n    ; Apply final permutation\n    mov rdi, rbx\n    call final_permutation\n    mov [r14], rax\n    \n    pop r14\n    pop r13\n    pop r12\n    pop rbx\n    pop rbp\n    ret\n\n; Triple DES (3DES) encryption\ndes3_encrypt:\n    push rbp\n    mov rbp, rsp\n    push rbx\n    push r12\n    push r13\n    push r14\n    \n    mov r12, rdi        ; plaintext\n    mov r13, rsi        ; three 64-bit keys\n    mov r14, rdx        ; output buffer\n    \n    ; First DES encryption with K1\n    mov rdi, r12\n    mov rsi, r13        ; K1\n    mov rdx, r14\n    call des_encrypt\n    \n    ; DES decryption with K2\n    mov rdi, [r14]      ; result from first encryption\n    mov rsi, [r13+8]    ; K2\n    mov rdx, r14\n    call des_decrypt    ; Note: decrypt for 3DES EDE\n    \n    ; Second DES encryption with K3 (or K1 for 2-key 3DES)\n    mov rdi, [r14]      ; result from decryption\n    mov rsi, [r13+16]   ; K3\n    mov rdx, r14\n    call des_encrypt\n    \n    pop r14\n    pop r13\n    pop r12\n    pop rbx\n    pop rbp\n    ret\n\n; DES F function implementation\ndes_f_function:\n    push rbp\n    mov rbp, rsp\n    \n    ; Expand 32-bit R to 48-bit\n    call expansion_permutation\n    \n    ; XOR with round key\n    xor rax, rsi\n    \n    ; Apply S-boxes (8 S-boxes, 6 bits each -> 4 bits each)\n    call apply_sboxes\n    \n    ; Apply P permutation\n    call p_permutation\n    \n    pop rbp\n    ret",
  "description": "x86-64 assembly implementation of DES and Triple DES with key scheduling and encryption rounds",
  "expected_analysis_points": [
    "symmetric ciphers vulnerable to Grover's algorithm (AES-128, 3DES, DES, RC4)",
    "legacy cryptographic implementations with known weaknesses",
    "block cipher patterns with substitution-permutation networks"
  ],
  "vulnerable_algorithms_present": ["DES", "3DES"],
  "algorithm_categories": ["grover_vulnerable", "other_vulnerable"],
  "korean_algorithms": [],
  "difficulty": "hard",
  "tags": ["des", "3des", "assembly", "legacy", "feistel"]
}