{
  "input_data": "from cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives import hashes\nimport hashlib\n\nclass EllipticCurveManager:\n    def __init__(self):\n        # Using NIST P-256 curve - vulnerable to quantum attacks\n        self.private_key = ec.generate_private_key(ec.SECP256R1())\n        self.public_key = self.private_key.public_key()\n        \n    def generate_shared_secret(self, peer_public_key):\n        # ECDH key exchange - quantum vulnerable\n        shared_key = self.private_key.exchange(\n            ec.ECDH(), peer_public_key\n        )\n        # Weak key derivation\n        return hashlib.md5(shared_key).digest()\n    \n    def sign_message(self, message):\n        # ECDSA with weak hash\n        signature = self.private_key.sign(\n            message.encode(),\n            ec.ECDSA(hashes.SHA1())  # Quantum vulnerable\n        )\n        return signature\n    \n    def create_key_pair_secp384r1(self):\n        # Another quantum-vulnerable curve\n        return ec.generate_private_key(ec.SECP384R1())\n    \n    def bitcoin_style_signing(self, transaction_hash):\n        # Bitcoin uses secp256k1 - also quantum vulnerable\n        bitcoin_key = ec.generate_private_key(ec.SECP256K1())\n        return bitcoin_key.sign(\n            transaction_hash,\n            ec.ECDSA(hashes.SHA256())\n        )",
  "description": "Elliptic Curve Cryptography implementation using quantum-vulnerable NIST curves and weak hashing",
  "expected_analysis_points": [
    "elliptic curve cryptography (ECC/ECDSA/ECDH) implementations",
    "discrete logarithm based algorithms (DSA, DH, ElGamal)",
    "weak hash functions (MD5, SHA-1, SHA-256 with reduced security)"
  ],
  "vulnerable_algorithms_present": ["ECDSA", "ECDH", "SECP256R1", "SECP384R1", "SECP256K1", "MD5", "SHA-1"],
  "algorithm_categories": ["shor_vulnerable", "grover_vulnerable"],
  "korean_algorithms": [],
  "difficulty": "hard",
  "tags": ["ecc", "ecdsa", "ecdh", "bitcoin", "nist-curves"]
}